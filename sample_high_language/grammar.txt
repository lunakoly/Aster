rules {
    buildSequenceRule binary
    buildSequenceRule octal
    buildSequenceRule decimal
    buildSequenceRule hexadecimal

    rule binaryNumber {
        @binarySequence~b -> Number { value = $0, base = 2 }
    }

    rule octalNumber {
        @octalSequence~o -> Number { value = $0, base = 8 }
    }

    rule hexadecimalNumber {
        @hexadecimalSequence~h -> Number { value = $0, base = 16 }
    }

    rule decimalNumber {
        @decimalSequence -> Number { value = $0, base = 10 }
    }

    rule name {
        @name~#nameInner -> $0 += $1
        @nameStart -> $0
    }

    rule identifier {
        @name -> Identifier { name = $0 }
    }

    build~sequence~rule blank
    build~sequence~rule notBlank

    rule errorToken {
        @error~#notBlank -> $0 += $1
        @blankSequence -> $0
        @notBlankSequence -> $0
    }

    rule error {
        @errorToken -> Error { token = $0 }
    }

    rule anyToken {
        @binaryNumber -> $0
        @octalNumber -> $0
        @hexadecimalNumber -> $0
        @decimalNumber -> $0
        @identifier -> $0
        @error -> $0
    }

    rule item {
        @anyToken -> $0
        ( @expression ) -> $1
        @item ( @expressionList ) -> Call { receiver = $0, arguments = $2 }
        @item [ @expressionList ] -> Subscript { receiver = $0, arguments = $2 }
    }

    rule unaryMinus {
        - $upper -> UnaryMinus { target = $1 }
    }

    rule timesOrDivide {
        $self * $upper -> Times { lefter = $0, righter = $2 }
        $self / $upper -> Divide { lefter = $0, righter = $2 }
        $upper -> $0
    }

    rule plusOrMinus {
        $self + $upper -> Plus { lefter = $0, righter = $2 }
        $self - $upper -> Minus { lefter = $0, righter = $2 }
        $upper -> $0
    }

    rule expression {
        @upper -> $0
    }

    rule expressionList {
        @expressionList , @expression -> $0.values += $1
        @expression -> List { values = [$0] }
    }

    buildCommaListRule expression
}

topLevelRule = expression
